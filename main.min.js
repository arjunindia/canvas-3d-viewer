import {
    parseSTL
} from "./parse_stl.js";

const ctx = display.getContext("2d");

const canvas = display;

const width = canvas.width;

const height = canvas.height;

ctx.imageSmoothingQuality = "high";

ctx.imageSmoothingEnabled = true;

ctx.textRendering = "optimizeSpeed";

ctx.drawFocusIfNeeded;

let pageZoom = window.devicePixelRatio || 1;

const clipZ = .5;

const project3dPoint = ({
    x,
    y,
    z
}) => {
    const clippedZ = Math.max(z, clipZ);
    return {
        x: x / clippedZ,
        y: y / clippedZ
    };
};

const cartesianToJSCoordinate = ({
    x,
    y
}) => {
    return {
        x: (x + 1) / 2 * width,
        y: (1 - (y + 1) / 2) * height
    };
};

const printPoint = ({
    x,
    y
}) => {
    ctx.fillRect(x, y, 5, 5);
};

function rotate_axis(point, axis, angle) {
    const {
        x,
        y,
        z
    } = point;
    if (axis === "y") {
        const rotatedX = x * Math.cos(angle) - z * Math.sin(angle);
        const rotatedZ = x * Math.sin(angle) + z * Math.cos(angle);
        return {
            x: rotatedX,
            y: y,
            z: rotatedZ
        };
    } else if (axis === "x") {
        const rotatedY = y * Math.cos(angle) + z * Math.sin(angle);
        const rotatedZ = -y * Math.sin(angle) + z * Math.cos(angle);
        return {
            x: x,
            y: rotatedY,
            z: rotatedZ
        };
    } else {
        const rotatedX = x * Math.cos(angle) + y * Math.sin(angle);
        const rotatedY = -x * Math.sin(angle) + y * Math.cos(angle);
        return {
            x: rotatedX,
            y: rotatedY,
            z: z
        };
    }
}

const transposeZ = (point, delta = 110) => {
    return {
        x: point.x,
        y: point.y,
        z: point.z + delta
    };
};

const transposeY = (point, delta = 200) => {
    return {
        x: point.x,
        y: point.y + delta,
        z: point.z
    };
};

const transposeX = (point, delta = 200) => {
    return {
        x: point.x + delta,
        y: point.y,
        z: point.z
    };
};

function isFrontFacing(polygon) {
    const transformedPoints = polygon.transformedPoints;
    const v0 = transformedPoints[0];
    const v1 = transformedPoints[1];
    const v2 = transformedPoints[2];
    const edge1 = {
        x: v1.x - v0.x,
        y: v1.y - v0.y,
        z: v1.z - v0.z
    };
    const edge2 = {
        x: v2.x - v0.x,
        y: v2.y - v0.y,
        z: v2.z - v0.z
    };
    const normal = {
        x: edge1.y * edge2.z - edge1.z * edge2.y,
        y: edge1.z * edge2.x - edge1.x * edge2.z,
        z: edge1.x * edge2.y - edge1.y * edge2.x
    };
    const viewVector = v0;
    const dotProduct = normal.x * viewVector.x + normal.y * viewVector.y + normal.z * viewVector.z;
    return dotProduct < 0;
}

const stlData = await fetch("models/Utah_teapot_(solid).stl").then(res => res.arrayBuffer());

const {
    points,
    connections,
    polygons,
    isManifold,
    dimensions,
    center
} = parseSTL(stlData);

const maxDimension = Math.max(dimensions.width, dimensions.height, dimensions.depth);

const radius = maxDimension / 2;

const verticalFOV_deg = 60;

const halfFOV_rad = verticalFOV_deg / 2 * (Math.PI / 180);

let zDistance = radius / Math.tan(halfFOV_rad);

const paddingFactor = 1.2;

zDistance = zDistance * paddingFactor;

console.log("Calculated Z-Axis Distance:", zDistance);

const zoomFactor = zDistance;

const centerOffset = {
    x: -center.x,
    y: -center.y,
    z: -center.z
};

const applyCenterOffset = point => {
    return {
        x: point.x + centerOffset.x,
        y: point.y + centerOffset.y,
        z: point.z + centerOffset.z
    };
};

points.forEach((point, index) => {
    let rotatedPoint = rotate_axis(point, "x", Math.PI / 2);
    rotatedPoint = transposeY(rotatedPoint, -10);
    points[index] = rotatedPoint;
});

polygons.forEach(polygon => {
    let rotatedNormal = rotate_axis(polygon.normal, "x", Math.PI / 2);
    rotatedNormal = transposeX(rotatedNormal, centerOffset.x);
    rotatedNormal = transposeY(rotatedNormal, centerOffset.y);
    const transformedNormal = transposeZ(rotatedNormal, centerOffset.z);
    polygon.normal = transformedNormal;
});

let lastTime = performance.now();

let frameCount = 0;

let fps = 0;

function draw(delta = .01) {
    ctx.clearRect(0, 0, width, height);
    const renderablePolygons = polygons.map(polygon => {
        const originalPoints = polygon.points.map(index => points[index]);
        let transformedPoints = originalPoints.map(point => rotate_axis(point, "y", delta));
        transformedPoints = transformedPoints.map(point => applyCenterOffset(point));
        transformedPoints = transformedPoints.map(point => transposeZ(point, zoomFactor));
        const avgZ = transformedPoints.reduce((acc, p) => acc + p.z, 0) / transformedPoints.length;
        const projected2DPoints = transformedPoints.map(p => project3dPoint(p));
        const cartesian2DPoints = projected2DPoints.map(p => cartesianToJSCoordinate(p));
        const gradientForPolygon = ctx.createLinearGradient(cartesian2DPoints[0].x, cartesian2DPoints[0].y, cartesian2DPoints[1].x, cartesian2DPoints[1].y);
        for (let j = 0; j < projected2DPoints.length; j++) {
            const point = projected2DPoints[j];
            let stop = `hsl(${Math.round(360 * point.x)}, 100%, 50%)`;
            gradientForPolygon.addColorStop(j / projected2DPoints.length, stop);
        }
        return {
            originalPolygon: polygon,
            transformedPoints: transformedPoints,
            projected2DPoints: projected2DPoints,
            cartesian2DPoints: cartesian2DPoints,
            gradientForPolygon: gradientForPolygon,
            depth: avgZ
        };
    });
    renderablePolygons.sort((a, b) => b.depth - a.depth);
    for (let i = 0; i < renderablePolygons.length; i++) {
        const polygon = renderablePolygons[i];
        if (isManifold && !isFrontFacing(polygon)) {
            continue;
        }
        const projectedPointsCurr = polygon.projected2DPoints;
        const gradientForPolygon = polygon.gradientForPolygon;
        ctx.fillStyle = gradientForPolygon;
        ctx.beginPath();
        ctx.moveTo(polygon.cartesian2DPoints[0].x, polygon.cartesian2DPoints[0].y);
        for (let j = 1; j < projectedPointsCurr.length; j++) {
            ctx.lineTo(polygon.cartesian2DPoints[j].x, polygon.cartesian2DPoints[j].y);
        }
        ctx.fill();
    }
    frameCount++;
    const currentTime = performance.now();
    const elapsedTime = currentTime - lastTime;
    if (elapsedTime >= 1e3) {
        fps = frameCount;
        frameCount = 0;
        lastTime = currentTime;
    }
    ctx.fillStyle = "#0f0";
    ctx.font = `${16 * 4 * pageZoom}px monospace`;
    ctx.fillText(`FPS: ${fps}`, 10, 50);
    setTimeout(() => draw(delta + .01), 1e3 / 60);
}

draw();
//# sourceMappingURL=main.min.js.map